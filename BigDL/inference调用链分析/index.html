<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <link rel="shortcut icon" href="../../img/favicon.ico">

    <title>inference调用链分析 - SparkDL</title>

    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="../..">SparkDL</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">BigDL代码分析 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../数据表示/">数据表示</a>
</li>

                        
                            
<li >
    <a href="../模型定义/">模型定义</a>
</li>

                        
                            
<li >
    <a href="../Module/">Module</a>
</li>

                        
                            
<li >
    <a href="../Transformer/">Transformer.md</a>
</li>

                        
                            
<li class="active">
    <a href="./">inference调用链分析</a>
</li>

                        
                            
<li >
    <a href="../forward/">Forward</a>
</li>

                        
                            
<li >
    <a href="../Tensor运算/">Tensor运算</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fa fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../Transformer/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../forward/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/SparkDL/docs/edit/master/docs/BigDL/inference调用链分析.md">Edit on SparkDL</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#inference">inference调用链分析</a></li>
            <li class="second-level"><a href="#lenet">lenet模型定义</a></li>
                
            <li class="second-level"><a href="#inference_1">inference调用链</a></li>
                
            <li class="second-level"><a href="#evaluator">Evaluator</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="inference">inference调用链分析</h1>
<p>以最简单的lenet5为例, 探究inference过程的调用链</p>
<p>示例代码位于'spark/dl/src/main/scala/com/pzque/sparkdl/lenet', 模型的checkpoint已保存好, 下载好数据后可以直接运行'Test.scala'查看测试集上的推断准确率.</p>
<h2 id="lenet">lenet模型定义</h2>
<p>首先看一下lenet模型的定义.</p>
<p><code>apply</code>和<code>graph</code>函数分别使用了Sequential和Graph的API定义模型, 二者是等价的.</p>
<p>模型的结构非常简单, 在测试集上可以达到98.93%的准确率.</p>
<pre><code class="scala">28*28 -&gt; (Conv -&gt; MaxPooling)*2 -&gt; (FullConnected)*2 -&gt; LogSoftMax
</code></pre>

<pre><code class="scala">object LeNet5 {
  def apply(classNum: Int): Module[Float] = {
    val model = Sequential()
    model.add(Reshape(Array(1, 28, 28)))
      .add(SpatialConvolution(1, 6, 5, 5).setName(&quot;conv1_5x5&quot;))
      .add(Tanh())
      .add(SpatialMaxPooling(2, 2, 2, 2))
      .add(Tanh())
      .add(SpatialConvolution(6, 12, 5, 5).setName(&quot;conv2_5x5&quot;))
      .add(SpatialMaxPooling(2, 2, 2, 2))
      .add(Reshape(Array(12 * 4 * 4)))
      .add(Linear(12 * 4 * 4, 100).setName(&quot;fc1&quot;))
      .add(Tanh())
      .add(Linear(100, classNum).setName(&quot;fc2&quot;))
      .add(LogSoftMax())
  }
  def graph(classNum: Int): Module[Float] = {
    val input = Reshape(Array(1, 28, 28)).inputs()
    val conv1 = SpatialConvolution(1, 6, 5, 5).setName(&quot;conv1_5x5&quot;).inputs(input)
    val tanh1 = Tanh().inputs(conv1)
    val pool1 = SpatialMaxPooling(2, 2, 2, 2).inputs(tanh1)
    val tanh2 = Tanh().inputs(pool1)
    val conv2 = SpatialConvolution(6, 12, 5, 5).setName(&quot;conv2_5x5&quot;).inputs(tanh2)
    val pool2 = SpatialMaxPooling(2, 2, 2, 2).inputs(conv2)
    val reshape = Reshape(Array(12 * 4 * 4)).inputs(pool2)
    val fc1 = Linear(12 * 4 * 4, 100).setName(&quot;fc1&quot;).inputs(reshape)
    val tanh3 = Tanh().inputs(fc1)
    val fc2 = Linear(100, classNum).setName(&quot;fc2&quot;).inputs(tanh3)
    val output = LogSoftMax().inputs(fc2)

    Graph(input, output)
  }
}
</code></pre>

<h2 id="inference_1">inference调用链</h2>
<p>infrence的核心代码如下: </p>
<pre><code class="scala">// 加载测试数据, 调用SparkContext类的parallize方法将其转为RDD
val rddData: RDD[ByteRecord] = sc.parallelize(load(validationData, validationLabel), partitionNum)

// 定义一个数据预处理器, 将ByteRecord格式转为Sample[Float]
val transformer: Transformer[ByteRecord, Sample[Float]] =
BytesToGreyImg(28, 28) -&gt; GreyImgNormalizer(testMean, testStd) -&gt; GreyImgToSample()

// 使用transformer构造验证集RDD
val evaluationSet: RDD[Sample[Float]] = transformer(rddData)

// 加载模型
val model = Module.load[Float](param.model)

// 执行模型, 获取结果
val result = model.evaluate(evaluationSet,
Array(new Top1Accuracy[Float]), Some(param.batchSize))
</code></pre>

<p>前面的一堆都是使用spark的RDD进行数据预处理与转换, 最后得到<code>evaluationSet</code>, 也是一个RDD, 元素是<code>Sample[Flaot]</code>的类型.</p>
<p>我们看到其先是通过<code>Module.load[Float]</code>将模型加载进来, 然后利用模型执行evaluate操作.</p>
<p>我们需要关注这一句:</p>
<pre><code class="scala">model.evaluate(evaluationSet,
        Array(new Top1Accuracy[Float]), 
        Some(param.batchSize))
</code></pre>

<p>找到它的定义, 位于<code>AbstractModule</code>类:</p>
<pre><code class="scala">/**
* use ValidationMethod to evaluate module on the given rdd dataset
* @param dataset dataset for test
* @param vMethods validation methods
* @param batchSize total batchsize of all partitions,
*                  optional param and default 4 * partitionNum of dataset
* @return
*/
final def evaluate(
dataset: RDD[Sample[T]],
vMethods: Array[ValidationMethod[T]],
batchSize: Option[Int] = None
): Array[(ValidationResult, ValidationMethod[T])] = {
Evaluator(this).test(dataset, vMethods, batchSize)
}
</code></pre>

<p>三个参数,</p>
<ul>
<li><code>dataset</code>: 是你要运行模型的数据集</li>
<li><code>vMethods</code>: 是最后模型运行完成运行的一些统计工作, 比如这里的Top1Accuracy就是统计一下准确率 </li>
<li><code>batchSize</code>: 注意这个不是机器学习的那个batchsize(每个batch的大小), 而是将全部的数据集分成多少batch</li>
</ul>
<p>然后最后执行模型的代码就是<code>Evaluator(this).test(dataset, vMethods, batchSize)</code>了, 下面来看一下它的实现.</p>
<h2 id="evaluator">Evaluator</h2>
<pre><code class="scala">/**
 * model evaluator
 * @param model model to be evaluated
 */
class Evaluator[T: ClassTag] private[optim](model: Module[T])(implicit ev: TensorNumeric[T])
  extends Serializable {

  private val batchPerPartition = 4

  /**
   * Applies ValidationMethod to the model and rdd dataset.
   * @param vMethods
   * @param batchSize total batchsize
   * @return
   */
  def test(dataset: RDD[Sample[T]],
   vMethods: Array[ValidationMethod[T]],
   batchSize: Option[Int] = None): Array[(ValidationResult, ValidationMethod[T])] = {

    val modelBroad = ModelBroadcast[T]().broadcast(dataset.sparkContext, model.evaluate())
    val partitionNum = dataset.partitions.length

    val totalBatch = batchSize.getOrElse(batchPerPartition * partitionNum)
    val otherBroad = dataset.sparkContext.broadcast(vMethods, SampleToMiniBatch(
      batchSize = totalBatch, partitionNum = Some(partitionNum)))

    dataset.mapPartitions(partition =&gt; {
      val localModel = modelBroad.value()
      val localMethod = otherBroad.value._1.map(_.clone())
      val localTransformer = otherBroad.value._2.cloneTransformer()
      val miniBatch = localTransformer(partition)
      miniBatch.map(batch =&gt; {
        val output = localModel.forward(batch.getInput())
        localMethod.map(validation =&gt; {
          validation(output, batch.getTarget())
        })
      })
    }).reduce((left, right) =&gt; {
        left.zip(right).map { case (l, r) =&gt; l + r }
    }).zip(vMethods)
  }
}
</code></pre>

<p>上面是这个类的全部代码, 这个类也只是在全局做调度, 很简单. 具体的执行逻辑当然还是在<code>AbstractModule</code>的实现类里定义.</p>
<p>如代码所示, 在一个RDD数据集上执行模型有如下几步:</p>
<p><strong>1.将模型广播到各个节点</strong></p>
<pre><code class="scala">val modelBroad = ModelBroadcast[T]().broadcast(dataset.sparkContext, model.evaluate())
</code></pre>

<p>这一句将模型拷贝到了每一个spark节点上, 让其都能访问到.</p>
<p><strong>2.将vMethods和一个能将数据集转为一个个batch的transformer广播到各个节点</strong></p>
<pre><code class="scala">val otherBroad = dataset.sparkContext.broadcast
(
 vMethods, 
 SampleToMiniBatch(batchSize = totalBatch, partitionNum = Some(partitionNum))
 )
</code></pre>

<p>这里注意一下一个scala语法的坑, 事实上<code>broadcast</code>函数只能接受一个参数, 但是scala支持函数不带括号的调用语法,
比如<code>a.add b</code>等价于<code>a.add(b)</code>, 所以这里的参数其实是一个Tuple: <code>(vMethods, SampleToMiniBatch(...))</code>.</p>
<p><strong>3.在每个节点执行一遍模型然后收集结果</strong></p>
<p>代码就是这一堆:</p>
<pre><code class="scala">dataset.mapPartitions(partition =&gt; {
  val localModel = modelBroad.value()
  val localMethod = otherBroad.value._1.map(_.clone())
  val localTransformer = otherBroad.value._2.cloneTransformer()
  val miniBatch = localTransformer(partition)
  miniBatch.map(batch =&gt; {
    val output = localModel.forward(batch.getInput())
    localMethod.map(validation =&gt; {
      validation(output, batch.getTarget())
    })
  })
}).reduce((left, right) =&gt; {
    left.zip(right).map { case (l, r) =&gt; l + r }
}).zip(vMethods)
</code></pre>

<p>先是最顶层的<code>mapPartitions</code>, 简单, spark的机制是一个节点保存一个partition, 所以呢这个就是在每个节点执行一遍后面的那个函数<code>partition=&gt;{...}</code>.</p>
<p><code>partition</code>这个参数就是一个数据分区了.</p>
<p>继续看函数体, 前3句:</p>
<pre><code class="scala">  val localModel = modelBroad.value()
  val localMethod = otherBroad.value._1.map(_.clone())
  val localTransformer = otherBroad.value._2.cloneTransformer()
</code></pre>

<p>前面说了在前2步广播了几个变量, 这里就是在slave上访问那几个变量, <code>localModel</code>是模型, <code>localMethod</code>是那个统计方法数组,
<code>localTransformer</code>就是把数据转成一个个batch的对象.</p>
<p>然后就是调用这个<code>localTransformer</code>将数据集转成batch.</p>
<p>后面的代码, 除了这一句:</p>
<p><code>scala
val output = localModel.forward(batch.getInput())</code></p>
<p>是运行模型inference外, 其他都是在收集统计结果, 可以不必关注.</p>
<p>所以我们后面至于关注模型如何forward.</p>
<p>这个留在下一节 <a href="../forward/">forward</a>详述.</p></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="../../js/jquery-1.10.2.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '../..';
    </script>
    <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
    <script src="../../js/base.js"></script>
    <script src="../../search/require.js"></script>
    <script src="../../search/search.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
